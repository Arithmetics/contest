input UserRelateToOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  disconnectAll: Boolean
}

input ChoiceRelateToOneInput {
  create: ChoiceCreateInput
  connect: ChoiceWhereUniqueInput
  disconnect: ChoiceWhereUniqueInput
  disconnectAll: Boolean
}

"""
 A keystone list
"""
type Bet {
  id: ID!
  user: User
  choice: Choice
}

input BetWhereInput {
  AND: [BetWhereInput]
  OR: [BetWhereInput]
  id: ID
  id_not: ID
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_not_in: [ID]
  user: UserWhereInput
  user_is_null: Boolean
  choice: ChoiceWhereInput
  choice_is_null: Boolean
}

input BetWhereUniqueInput {
  id: ID!
}

enum SortBetsBy {
  id_ASC
  id_DESC
  user_ASC
  user_DESC
  choice_ASC
  choice_DESC
}

input BetUpdateInput {
  user: UserRelateToOneInput
  choice: ChoiceRelateToOneInput
}

input BetsUpdateInput {
  id: ID!
  data: BetUpdateInput
}

input BetCreateInput {
  user: UserRelateToOneInput
  choice: ChoiceRelateToOneInput
}

input BetsCreateInput {
  data: BetCreateInput
}

enum ChoiceSelectionType {
  OVER
  UNDER
  AWAY
  HOME
}

input LineRelateToOneInput {
  create: LineCreateInput
  connect: LineWhereUniqueInput
  disconnect: LineWhereUniqueInput
  disconnectAll: Boolean
}

input BetRelateToManyInput {
  create: [BetCreateInput]
  connect: [BetWhereUniqueInput]
  disconnect: [BetWhereUniqueInput]
  disconnectAll: Boolean
}

"""
 A keystone list
"""
type Choice {
  id: ID!
  selection: ChoiceSelectionType
  isWin: Boolean
  line: Line
  bets(
    where: BetWhereInput
    search: String
    sortBy: [SortBetsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Bet!]!
  _betsMeta(
    where: BetWhereInput
    search: String
    sortBy: [SortBetsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta
  labelName: String
}

input ChoiceWhereInput {
  AND: [ChoiceWhereInput]
  OR: [ChoiceWhereInput]
  id: ID
  id_not: ID
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_not_in: [ID]
  selection: ChoiceSelectionType
  selection_not: ChoiceSelectionType
  selection_in: [ChoiceSelectionType]
  selection_not_in: [ChoiceSelectionType]
  isWin: Boolean
  isWin_not: Boolean
  line: LineWhereInput
  line_is_null: Boolean

  """
   condition must be true for all nodes
  """
  bets_every: BetWhereInput

  """
   condition must be true for at least 1 node
  """
  bets_some: BetWhereInput

  """
   condition must be false for all nodes
  """
  bets_none: BetWhereInput
}

input ChoiceWhereUniqueInput {
  id: ID!
}

enum SortChoicesBy {
  id_ASC
  id_DESC
  selection_ASC
  selection_DESC
  isWin_ASC
  isWin_DESC
  line_ASC
  line_DESC
  bets_ASC
  bets_DESC
}

input ChoiceUpdateInput {
  selection: ChoiceSelectionType
  isWin: Boolean
  line: LineRelateToOneInput
  bets: BetRelateToManyInput
}

input ChoicesUpdateInput {
  id: ID!
  data: ChoiceUpdateInput
}

input ChoiceCreateInput {
  selection: ChoiceSelectionType
  isWin: Boolean
  line: LineRelateToOneInput
  bets: BetRelateToManyInput
}

input ChoicesCreateInput {
  data: ChoiceCreateInput
}

enum ContestStatusType {
  OPEN
  IN_PROGRESS
  COMPLETE
}

input CloudImageRelateToOneInput {
  create: CloudImageCreateInput
  connect: CloudImageWhereUniqueInput
  disconnect: CloudImageWhereUniqueInput
  disconnectAll: Boolean
}

input LineRelateToManyInput {
  create: [LineCreateInput]
  connect: [LineWhereUniqueInput]
  disconnect: [LineWhereUniqueInput]
  disconnectAll: Boolean
}

input RegistrationRelateToManyInput {
  create: [RegistrationCreateInput]
  connect: [RegistrationWhereUniqueInput]
  disconnect: [RegistrationWhereUniqueInput]
  disconnectAll: Boolean
}

"""
 A keystone list
"""
type Contest {
  id: ID!
  name: String
  description: String
  status: ContestStatusType
  entryFee: Int
  image: CloudImage
  lines(
    where: LineWhereInput
    search: String
    sortBy: [SortLinesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Line!]!
  _linesMeta(
    where: LineWhereInput
    search: String
    sortBy: [SortLinesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta
  registrations(
    where: RegistrationWhereInput
    search: String
    sortBy: [SortRegistrationsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Registration!]!
  _registrationsMeta(
    where: RegistrationWhereInput
    search: String
    sortBy: [SortRegistrationsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta
}

input ContestWhereInput {
  AND: [ContestWhereInput]
  OR: [ContestWhereInput]
  id: ID
  id_not: ID
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_not_in: [ID]
  name: String
  name_not: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  name_i: String
  name_not_i: String
  name_contains_i: String
  name_not_contains_i: String
  name_starts_with_i: String
  name_not_starts_with_i: String
  name_ends_with_i: String
  name_not_ends_with_i: String
  name_in: [String]
  name_not_in: [String]
  description: String
  description_not: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  description_i: String
  description_not_i: String
  description_contains_i: String
  description_not_contains_i: String
  description_starts_with_i: String
  description_not_starts_with_i: String
  description_ends_with_i: String
  description_not_ends_with_i: String
  description_in: [String]
  description_not_in: [String]
  status: ContestStatusType
  status_not: ContestStatusType
  status_in: [ContestStatusType]
  status_not_in: [ContestStatusType]
  entryFee: Int
  entryFee_not: Int
  entryFee_lt: Int
  entryFee_lte: Int
  entryFee_gt: Int
  entryFee_gte: Int
  entryFee_in: [Int]
  entryFee_not_in: [Int]
  image: CloudImageWhereInput
  image_is_null: Boolean

  """
   condition must be true for all nodes
  """
  lines_every: LineWhereInput

  """
   condition must be true for at least 1 node
  """
  lines_some: LineWhereInput

  """
   condition must be false for all nodes
  """
  lines_none: LineWhereInput

  """
   condition must be true for all nodes
  """
  registrations_every: RegistrationWhereInput

  """
   condition must be true for at least 1 node
  """
  registrations_some: RegistrationWhereInput

  """
   condition must be false for all nodes
  """
  registrations_none: RegistrationWhereInput
}

input ContestWhereUniqueInput {
  id: ID!
}

enum SortContestsBy {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  status_ASC
  status_DESC
  entryFee_ASC
  entryFee_DESC
  image_ASC
  image_DESC
  lines_ASC
  lines_DESC
  registrations_ASC
  registrations_DESC
}

input ContestUpdateInput {
  name: String
  description: String
  status: ContestStatusType
  entryFee: Int
  image: CloudImageRelateToOneInput
  lines: LineRelateToManyInput
  registrations: RegistrationRelateToManyInput
}

input ContestsUpdateInput {
  id: ID!
  data: ContestUpdateInput
}

input ContestCreateInput {
  name: String
  description: String
  status: ContestStatusType
  entryFee: Int
  image: CloudImageRelateToOneInput
  lines: LineRelateToManyInput
  registrations: RegistrationRelateToManyInput
}

input ContestsCreateInput {
  data: ContestCreateInput
}

type CloudinaryImage_File {
  id: ID
  path: String
  filename: String
  originalFilename: String
  mimetype: String
  encoding: String
  publicUrl: String
  publicUrlTransformed(transformation: CloudinaryImageFormat): String
}

"""
Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).
All options are strings as they ultimately end up in a URL.
"""
input CloudinaryImageFormat {
  """
   Rewrites the filename to be this pretty string. Do not include `/` or `.`
  """
  prettyName: String
  width: String
  height: String
  crop: String
  aspect_ratio: String
  gravity: String
  zoom: String
  x: String
  y: String
  format: String
  fetch_format: String
  quality: String
  radius: String
  angle: String
  effect: String
  opacity: String
  border: String
  background: String
  overlay: String
  underlay: String
  default_image: String
  delay: String
  color: String
  color_space: String
  dpr: String
  page: String
  density: String
  flags: String
  transformation: String
}

"""
 A keystone list
"""
type CloudImage {
  id: ID!
  image: CloudinaryImage_File
  altText: String
}

input CloudImageWhereInput {
  AND: [CloudImageWhereInput]
  OR: [CloudImageWhereInput]
  id: ID
  id_not: ID
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_not_in: [ID]
  image: String
  image_not: String
  image_in: [String]
  image_not_in: [String]
  altText: String
  altText_not: String
  altText_contains: String
  altText_not_contains: String
  altText_starts_with: String
  altText_not_starts_with: String
  altText_ends_with: String
  altText_not_ends_with: String
  altText_i: String
  altText_not_i: String
  altText_contains_i: String
  altText_not_contains_i: String
  altText_starts_with_i: String
  altText_not_starts_with_i: String
  altText_ends_with_i: String
  altText_not_ends_with_i: String
  altText_in: [String]
  altText_not_in: [String]
}

input CloudImageWhereUniqueInput {
  id: ID!
}

enum SortCloudImagesBy {
  id_ASC
  id_DESC
  altText_ASC
  altText_DESC
}

input CloudImageUpdateInput {
  image: Upload
  altText: String
}

input CloudImagesUpdateInput {
  id: ID!
  data: CloudImageUpdateInput
}

input CloudImageCreateInput {
  image: Upload
  altText: String
}

input CloudImagesCreateInput {
  data: CloudImageCreateInput
}

input ContestRelateToOneInput {
  create: ContestCreateInput
  connect: ContestWhereUniqueInput
  disconnect: ContestWhereUniqueInput
  disconnectAll: Boolean
}

input ChoiceRelateToManyInput {
  create: [ChoiceCreateInput]
  connect: [ChoiceWhereUniqueInput]
  disconnect: [ChoiceWhereUniqueInput]
  disconnectAll: Boolean
}

"""
 A keystone list
"""
type Line {
  id: ID!
  title: String
  closingTime: String
  benchmark: Float
  image: CloudImage
  contest: Contest
  choices(
    where: ChoiceWhereInput
    search: String
    sortBy: [SortChoicesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Choice!]!
  _choicesMeta(
    where: ChoiceWhereInput
    search: String
    sortBy: [SortChoicesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta
}

input LineWhereInput {
  AND: [LineWhereInput]
  OR: [LineWhereInput]
  id: ID
  id_not: ID
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_not_in: [ID]
  title: String
  title_not: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_i: String
  title_not_i: String
  title_contains_i: String
  title_not_contains_i: String
  title_starts_with_i: String
  title_not_starts_with_i: String
  title_ends_with_i: String
  title_not_ends_with_i: String
  title_in: [String]
  title_not_in: [String]
  closingTime: String
  closingTime_not: String
  closingTime_lt: String
  closingTime_lte: String
  closingTime_gt: String
  closingTime_gte: String
  closingTime_in: [String]
  closingTime_not_in: [String]
  benchmark: Float
  benchmark_not: Float
  benchmark_lt: Float
  benchmark_lte: Float
  benchmark_gt: Float
  benchmark_gte: Float
  benchmark_in: [Float]
  benchmark_not_in: [Float]
  image: CloudImageWhereInput
  image_is_null: Boolean
  contest: ContestWhereInput
  contest_is_null: Boolean

  """
   condition must be true for all nodes
  """
  choices_every: ChoiceWhereInput

  """
   condition must be true for at least 1 node
  """
  choices_some: ChoiceWhereInput

  """
   condition must be false for all nodes
  """
  choices_none: ChoiceWhereInput
}

input LineWhereUniqueInput {
  id: ID!
}

enum SortLinesBy {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  closingTime_ASC
  closingTime_DESC
  benchmark_ASC
  benchmark_DESC
  image_ASC
  image_DESC
  contest_ASC
  contest_DESC
  choices_ASC
  choices_DESC
}

input LineUpdateInput {
  title: String
  closingTime: String
  benchmark: Float
  image: CloudImageRelateToOneInput
  contest: ContestRelateToOneInput
  choices: ChoiceRelateToManyInput
}

input LinesUpdateInput {
  id: ID!
  data: LineUpdateInput
}

input LineCreateInput {
  title: String
  closingTime: String
  benchmark: Float
  image: CloudImageRelateToOneInput
  contest: ContestRelateToOneInput
  choices: ChoiceRelateToManyInput
}

input LinesCreateInput {
  data: LineCreateInput
}

"""
 A keystone list
"""
type User {
  id: ID!
  email: String
  name: String
  userName: String
  password_is_set: Boolean
  isAdmin: Boolean
  bets(
    where: BetWhereInput
    search: String
    sortBy: [SortBetsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Bet!]!
  _betsMeta(
    where: BetWhereInput
    search: String
    sortBy: [SortBetsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta
  avatarImage: CloudImage
  registrations(
    where: RegistrationWhereInput
    search: String
    sortBy: [SortRegistrationsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Registration!]!
  _registrationsMeta(
    where: RegistrationWhereInput
    search: String
    sortBy: [SortRegistrationsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta
  passwordResetToken_is_set: Boolean
  passwordResetIssuedAt: String
  passwordResetRedeemedAt: String
}

input UserWhereInput {
  AND: [UserWhereInput]
  OR: [UserWhereInput]
  id: ID
  id_not: ID
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_not_in: [ID]
  email: String
  email_not: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  email_i: String
  email_not_i: String
  email_contains_i: String
  email_not_contains_i: String
  email_starts_with_i: String
  email_not_starts_with_i: String
  email_ends_with_i: String
  email_not_ends_with_i: String
  email_in: [String]
  email_not_in: [String]
  name: String
  name_not: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  name_i: String
  name_not_i: String
  name_contains_i: String
  name_not_contains_i: String
  name_starts_with_i: String
  name_not_starts_with_i: String
  name_ends_with_i: String
  name_not_ends_with_i: String
  name_in: [String]
  name_not_in: [String]
  userName: String
  userName_not: String
  userName_contains: String
  userName_not_contains: String
  userName_starts_with: String
  userName_not_starts_with: String
  userName_ends_with: String
  userName_not_ends_with: String
  userName_i: String
  userName_not_i: String
  userName_contains_i: String
  userName_not_contains_i: String
  userName_starts_with_i: String
  userName_not_starts_with_i: String
  userName_ends_with_i: String
  userName_not_ends_with_i: String
  userName_in: [String]
  userName_not_in: [String]
  password_is_set: Boolean
  isAdmin: Boolean
  isAdmin_not: Boolean

  """
   condition must be true for all nodes
  """
  bets_every: BetWhereInput

  """
   condition must be true for at least 1 node
  """
  bets_some: BetWhereInput

  """
   condition must be false for all nodes
  """
  bets_none: BetWhereInput
  avatarImage: CloudImageWhereInput
  avatarImage_is_null: Boolean

  """
   condition must be true for all nodes
  """
  registrations_every: RegistrationWhereInput

  """
   condition must be true for at least 1 node
  """
  registrations_some: RegistrationWhereInput

  """
   condition must be false for all nodes
  """
  registrations_none: RegistrationWhereInput
  passwordResetToken_is_set: Boolean
  passwordResetIssuedAt: String
  passwordResetIssuedAt_not: String
  passwordResetIssuedAt_lt: String
  passwordResetIssuedAt_lte: String
  passwordResetIssuedAt_gt: String
  passwordResetIssuedAt_gte: String
  passwordResetIssuedAt_in: [String]
  passwordResetIssuedAt_not_in: [String]
  passwordResetRedeemedAt: String
  passwordResetRedeemedAt_not: String
  passwordResetRedeemedAt_lt: String
  passwordResetRedeemedAt_lte: String
  passwordResetRedeemedAt_gt: String
  passwordResetRedeemedAt_gte: String
  passwordResetRedeemedAt_in: [String]
  passwordResetRedeemedAt_not_in: [String]
}

input UserWhereUniqueInput {
  id: ID!
}

enum SortUsersBy {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  userName_ASC
  userName_DESC
  isAdmin_ASC
  isAdmin_DESC
  bets_ASC
  bets_DESC
  avatarImage_ASC
  avatarImage_DESC
  registrations_ASC
  registrations_DESC
  passwordResetIssuedAt_ASC
  passwordResetIssuedAt_DESC
  passwordResetRedeemedAt_ASC
  passwordResetRedeemedAt_DESC
}

input UserUpdateInput {
  email: String
  name: String
  userName: String
  password: String
  isAdmin: Boolean
  bets: BetRelateToManyInput
  avatarImage: CloudImageRelateToOneInput
  registrations: RegistrationRelateToManyInput
  passwordResetToken: String
  passwordResetIssuedAt: String
  passwordResetRedeemedAt: String
}

input UsersUpdateInput {
  id: ID!
  data: UserUpdateInput
}

input UserCreateInput {
  email: String
  name: String
  userName: String
  password: String
  isAdmin: Boolean
  bets: BetRelateToManyInput
  avatarImage: CloudImageRelateToOneInput
  registrations: RegistrationRelateToManyInput
  passwordResetToken: String
  passwordResetIssuedAt: String
  passwordResetRedeemedAt: String
}

input UsersCreateInput {
  data: UserCreateInput
}

"""
 A keystone list
"""
type Registration {
  id: ID!
  hasPaid: Boolean
  contest: Contest
  user: User
}

input RegistrationWhereInput {
  AND: [RegistrationWhereInput]
  OR: [RegistrationWhereInput]
  id: ID
  id_not: ID
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_not_in: [ID]
  hasPaid: Boolean
  hasPaid_not: Boolean
  contest: ContestWhereInput
  contest_is_null: Boolean
  user: UserWhereInput
  user_is_null: Boolean
}

input RegistrationWhereUniqueInput {
  id: ID!
}

enum SortRegistrationsBy {
  id_ASC
  id_DESC
  hasPaid_ASC
  hasPaid_DESC
  contest_ASC
  contest_DESC
  user_ASC
  user_DESC
}

input RegistrationUpdateInput {
  hasPaid: Boolean
  contest: ContestRelateToOneInput
  user: UserRelateToOneInput
}

input RegistrationsUpdateInput {
  id: ID!
  data: RegistrationUpdateInput
}

input RegistrationCreateInput {
  hasPaid: Boolean
  contest: ContestRelateToOneInput
  user: UserRelateToOneInput
}

input RegistrationsCreateInput {
  data: RegistrationCreateInput
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type _QueryMeta {
  count: Int
}

type Mutation {
  """
   Create a single Bet item.
  """
  createBet(data: BetCreateInput): Bet

  """
   Create multiple Bet items.
  """
  createBets(data: [BetsCreateInput]): [Bet]

  """
   Update a single Bet item by ID.
  """
  updateBet(id: ID!, data: BetUpdateInput): Bet

  """
   Update multiple Bet items by ID.
  """
  updateBets(data: [BetsUpdateInput]): [Bet]

  """
   Delete a single Bet item by ID.
  """
  deleteBet(id: ID!): Bet

  """
   Delete multiple Bet items by ID.
  """
  deleteBets(ids: [ID!]): [Bet]

  """
   Create a single Choice item.
  """
  createChoice(data: ChoiceCreateInput): Choice

  """
   Create multiple Choice items.
  """
  createChoices(data: [ChoicesCreateInput]): [Choice]

  """
   Update a single Choice item by ID.
  """
  updateChoice(id: ID!, data: ChoiceUpdateInput): Choice

  """
   Update multiple Choice items by ID.
  """
  updateChoices(data: [ChoicesUpdateInput]): [Choice]

  """
   Delete a single Choice item by ID.
  """
  deleteChoice(id: ID!): Choice

  """
   Delete multiple Choice items by ID.
  """
  deleteChoices(ids: [ID!]): [Choice]

  """
   Create a single Contest item.
  """
  createContest(data: ContestCreateInput): Contest

  """
   Create multiple Contest items.
  """
  createContests(data: [ContestsCreateInput]): [Contest]

  """
   Update a single Contest item by ID.
  """
  updateContest(id: ID!, data: ContestUpdateInput): Contest

  """
   Update multiple Contest items by ID.
  """
  updateContests(data: [ContestsUpdateInput]): [Contest]

  """
   Delete a single Contest item by ID.
  """
  deleteContest(id: ID!): Contest

  """
   Delete multiple Contest items by ID.
  """
  deleteContests(ids: [ID!]): [Contest]

  """
   Create a single CloudImage item.
  """
  createCloudImage(data: CloudImageCreateInput): CloudImage

  """
   Create multiple CloudImage items.
  """
  createCloudImages(data: [CloudImagesCreateInput]): [CloudImage]

  """
   Update a single CloudImage item by ID.
  """
  updateCloudImage(id: ID!, data: CloudImageUpdateInput): CloudImage

  """
   Update multiple CloudImage items by ID.
  """
  updateCloudImages(data: [CloudImagesUpdateInput]): [CloudImage]

  """
   Delete a single CloudImage item by ID.
  """
  deleteCloudImage(id: ID!): CloudImage

  """
   Delete multiple CloudImage items by ID.
  """
  deleteCloudImages(ids: [ID!]): [CloudImage]

  """
   Create a single Line item.
  """
  createLine(data: LineCreateInput): Line

  """
   Create multiple Line items.
  """
  createLines(data: [LinesCreateInput]): [Line]

  """
   Update a single Line item by ID.
  """
  updateLine(id: ID!, data: LineUpdateInput): Line

  """
   Update multiple Line items by ID.
  """
  updateLines(data: [LinesUpdateInput]): [Line]

  """
   Delete a single Line item by ID.
  """
  deleteLine(id: ID!): Line

  """
   Delete multiple Line items by ID.
  """
  deleteLines(ids: [ID!]): [Line]

  """
   Create a single User item.
  """
  createUser(data: UserCreateInput): User

  """
   Create multiple User items.
  """
  createUsers(data: [UsersCreateInput]): [User]

  """
   Update a single User item by ID.
  """
  updateUser(id: ID!, data: UserUpdateInput): User

  """
   Update multiple User items by ID.
  """
  updateUsers(data: [UsersUpdateInput]): [User]

  """
   Delete a single User item by ID.
  """
  deleteUser(id: ID!): User

  """
   Delete multiple User items by ID.
  """
  deleteUsers(ids: [ID!]): [User]

  """
   Create a single Registration item.
  """
  createRegistration(data: RegistrationCreateInput): Registration

  """
   Create multiple Registration items.
  """
  createRegistrations(data: [RegistrationsCreateInput]): [Registration]

  """
   Update a single Registration item by ID.
  """
  updateRegistration(id: ID!, data: RegistrationUpdateInput): Registration

  """
   Update multiple Registration items by ID.
  """
  updateRegistrations(data: [RegistrationsUpdateInput]): [Registration]

  """
   Delete a single Registration item by ID.
  """
  deleteRegistration(id: ID!): Registration

  """
   Delete multiple Registration items by ID.
  """
  deleteRegistrations(ids: [ID!]): [Registration]
  authenticateUserWithPassword(
    email: String!
    password: String!
  ): UserAuthenticationWithPasswordResult!
  createInitialUser(
    data: CreateInitialUserInput!
  ): UserAuthenticationWithPasswordSuccess!
  sendUserPasswordResetLink(email: String!): SendUserPasswordResetLinkResult
  redeemUserPasswordResetToken(
    email: String!
    token: String!
    password: String!
  ): RedeemUserPasswordResetTokenResult
  endSession: Boolean!
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

union AuthenticatedItem = User

union UserAuthenticationWithPasswordResult =
    UserAuthenticationWithPasswordSuccess
  | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  code: PasswordAuthErrorCode!
  message: String!
}

enum PasswordAuthErrorCode {
  FAILURE
  IDENTITY_NOT_FOUND
  SECRET_NOT_SET
  MULTIPLE_IDENTITY_MATCHES
  SECRET_MISMATCH
}

input CreateInitialUserInput {
  name: String
  userName: String
  email: String
  password: String
}

type SendUserPasswordResetLinkResult {
  code: PasswordResetRequestErrorCode!
  message: String!
}

enum PasswordResetRequestErrorCode {
  IDENTITY_NOT_FOUND
  MULTIPLE_IDENTITY_MATCHES
}

type ValidateUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

type RedeemUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

enum PasswordResetRedemptionErrorCode {
  FAILURE
  IDENTITY_NOT_FOUND
  MULTIPLE_IDENTITY_MATCHES
  TOKEN_NOT_SET
  TOKEN_MISMATCH
  TOKEN_EXPIRED
  TOKEN_REDEEMED
}

type Query {
  """
   Search for all Bet items which match the where clause.
  """
  allBets(
    where: BetWhereInput
    search: String
    sortBy: [SortBetsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Bet]

  """
   Search for the Bet item with the matching ID.
  """
  Bet(where: BetWhereUniqueInput!): Bet

  """
   Perform a meta-query on all Bet items which match the where clause.
  """
  _allBetsMeta(
    where: BetWhereInput
    search: String
    sortBy: [SortBetsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta

  """
   Search for all Choice items which match the where clause.
  """
  allChoices(
    where: ChoiceWhereInput
    search: String
    sortBy: [SortChoicesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Choice]

  """
   Search for the Choice item with the matching ID.
  """
  Choice(where: ChoiceWhereUniqueInput!): Choice

  """
   Perform a meta-query on all Choice items which match the where clause.
  """
  _allChoicesMeta(
    where: ChoiceWhereInput
    search: String
    sortBy: [SortChoicesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta

  """
   Search for all Contest items which match the where clause.
  """
  allContests(
    where: ContestWhereInput
    search: String
    sortBy: [SortContestsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Contest]

  """
   Search for the Contest item with the matching ID.
  """
  Contest(where: ContestWhereUniqueInput!): Contest

  """
   Perform a meta-query on all Contest items which match the where clause.
  """
  _allContestsMeta(
    where: ContestWhereInput
    search: String
    sortBy: [SortContestsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta

  """
   Search for all CloudImage items which match the where clause.
  """
  allCloudImages(
    where: CloudImageWhereInput
    search: String
    sortBy: [SortCloudImagesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [CloudImage]

  """
   Search for the CloudImage item with the matching ID.
  """
  CloudImage(where: CloudImageWhereUniqueInput!): CloudImage

  """
   Perform a meta-query on all CloudImage items which match the where clause.
  """
  _allCloudImagesMeta(
    where: CloudImageWhereInput
    search: String
    sortBy: [SortCloudImagesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta

  """
   Search for all Line items which match the where clause.
  """
  allLines(
    where: LineWhereInput
    search: String
    sortBy: [SortLinesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Line]

  """
   Search for the Line item with the matching ID.
  """
  Line(where: LineWhereUniqueInput!): Line

  """
   Perform a meta-query on all Line items which match the where clause.
  """
  _allLinesMeta(
    where: LineWhereInput
    search: String
    sortBy: [SortLinesBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta

  """
   Search for all User items which match the where clause.
  """
  allUsers(
    where: UserWhereInput
    search: String
    sortBy: [SortUsersBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [User]

  """
   Search for the User item with the matching ID.
  """
  User(where: UserWhereUniqueInput!): User

  """
   Perform a meta-query on all User items which match the where clause.
  """
  _allUsersMeta(
    where: UserWhereInput
    search: String
    sortBy: [SortUsersBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta

  """
   Search for all Registration items which match the where clause.
  """
  allRegistrations(
    where: RegistrationWhereInput
    search: String
    sortBy: [SortRegistrationsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): [Registration]

  """
   Search for the Registration item with the matching ID.
  """
  Registration(where: RegistrationWhereUniqueInput!): Registration

  """
   Perform a meta-query on all Registration items which match the where clause.
  """
  _allRegistrationsMeta(
    where: RegistrationWhereInput
    search: String
    sortBy: [SortRegistrationsBy!]
    orderBy: String
    first: Int
    skip: Int
  ): _QueryMeta
  authenticatedItem: AuthenticatedItem
  validateUserPasswordResetToken(
    email: String!
    token: String!
  ): ValidateUserPasswordResetTokenResult
  keystone: KeystoneMeta!
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  isOrderable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID!): KeystoneAdminUIFieldMetaItemView
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode!
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
