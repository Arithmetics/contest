type Mutation {
  sendUserPasswordResetLink(email: String!): SendUserPasswordResetLinkResult
  redeemUserPasswordResetToken(
    email: String!
    token: String!
    password: String!
  ): RedeemUserPasswordResetTokenResult
  createInitialUser(
    data: CreateInitialUserInput!
  ): UserAuthenticationWithPasswordSuccess!
  authenticateUserWithPassword(
    email: String!
    password: String!
  ): UserAuthenticationWithPasswordResult!
  createBet(data: BetCreateInput!): Bet
  createBets(data: [BetCreateInput!]!): [Bet]
  updateBet(where: BetWhereUniqueInput!, data: BetUpdateInput!): Bet
  updateBets(data: [BetUpdateArgs!]!): [Bet]
  deleteBet(where: BetWhereUniqueInput!): Bet
  deleteBets(where: [BetWhereUniqueInput!]!): [Bet]
  createChoice(data: ChoiceCreateInput!): Choice
  createChoices(data: [ChoiceCreateInput!]!): [Choice]
  updateChoice(where: ChoiceWhereUniqueInput!, data: ChoiceUpdateInput!): Choice
  updateChoices(data: [ChoiceUpdateArgs!]!): [Choice]
  deleteChoice(where: ChoiceWhereUniqueInput!): Choice
  deleteChoices(where: [ChoiceWhereUniqueInput!]!): [Choice]
  createCloudImage(data: CloudImageCreateInput!): CloudImage
  createCloudImages(data: [CloudImageCreateInput!]!): [CloudImage]
  updateCloudImage(
    where: CloudImageWhereUniqueInput!
    data: CloudImageUpdateInput!
  ): CloudImage
  updateCloudImages(data: [CloudImageUpdateArgs!]!): [CloudImage]
  deleteCloudImage(where: CloudImageWhereUniqueInput!): CloudImage
  deleteCloudImages(where: [CloudImageWhereUniqueInput!]!): [CloudImage]
  createContest(data: ContestCreateInput!): Contest
  createContests(data: [ContestCreateInput!]!): [Contest]
  updateContest(
    where: ContestWhereUniqueInput!
    data: ContestUpdateInput!
  ): Contest
  updateContests(data: [ContestUpdateArgs!]!): [Contest]
  deleteContest(where: ContestWhereUniqueInput!): Contest
  deleteContests(where: [ContestWhereUniqueInput!]!): [Contest]
  createLine(data: LineCreateInput!): Line
  createLines(data: [LineCreateInput!]!): [Line]
  updateLine(where: LineWhereUniqueInput!, data: LineUpdateInput!): Line
  updateLines(data: [LineUpdateArgs!]!): [Line]
  deleteLine(where: LineWhereUniqueInput!): Line
  deleteLines(where: [LineWhereUniqueInput!]!): [Line]
  createRegistration(data: RegistrationCreateInput!): Registration
  createRegistrations(data: [RegistrationCreateInput!]!): [Registration]
  updateRegistration(
    where: RegistrationWhereUniqueInput!
    data: RegistrationUpdateInput!
  ): Registration
  updateRegistrations(data: [RegistrationUpdateArgs!]!): [Registration]
  deleteRegistration(where: RegistrationWhereUniqueInput!): Registration
  deleteRegistrations(where: [RegistrationWhereUniqueInput!]!): [Registration]
  createRuleSet(data: RuleSetCreateInput!): RuleSet
  createRuleSets(data: [RuleSetCreateInput!]!): [RuleSet]
  updateRuleSet(
    where: RuleSetWhereUniqueInput!
    data: RuleSetUpdateInput!
  ): RuleSet
  updateRuleSets(data: [RuleSetUpdateArgs!]!): [RuleSet]
  deleteRuleSet(where: RuleSetWhereUniqueInput!): RuleSet
  deleteRuleSets(where: [RuleSetWhereUniqueInput!]!): [RuleSet]
  createStanding(data: StandingCreateInput!): Standing
  createStandings(data: [StandingCreateInput!]!): [Standing]
  updateStanding(
    where: StandingWhereUniqueInput!
    data: StandingUpdateInput!
  ): Standing
  updateStandings(data: [StandingUpdateArgs!]!): [Standing]
  deleteStanding(where: StandingWhereUniqueInput!): Standing
  deleteStandings(where: [StandingWhereUniqueInput!]!): [Standing]
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  endSession: Boolean!
}

type SendUserPasswordResetLinkResult {
  code: PasswordResetRequestErrorCode!
  message: String!
}

enum PasswordResetRequestErrorCode {
  IDENTITY_NOT_FOUND
  MULTIPLE_IDENTITY_MATCHES
}

type ValidateUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

type RedeemUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

enum PasswordResetRedemptionErrorCode {
  FAILURE
  IDENTITY_NOT_FOUND
  MULTIPLE_IDENTITY_MATCHES
  TOKEN_NOT_SET
  TOKEN_MISMATCH
  TOKEN_EXPIRED
  TOKEN_REDEEMED
}

input CreateInitialUserInput {
  email: String
  name: String
  userName: String
  password: String
}

union AuthenticatedItem = User

union UserAuthenticationWithPasswordResult =
    UserAuthenticationWithPasswordSuccess
  | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  code: PasswordAuthErrorCode!
  message: String!
}

enum PasswordAuthErrorCode {
  FAILURE
  IDENTITY_NOT_FOUND
  SECRET_NOT_SET
  MULTIPLE_IDENTITY_MATCHES
  SECRET_MISMATCH
}

type Bet {
  id: ID!
  user: User
  choice: Choice
  isSuper: Boolean
}

input BetWhereInput {
  AND: [BetWhereInput!]
  OR: [BetWhereInput!]
  NOT: [BetWhereInput!]
  id: IDFilter
  user: UserWhereInput
  choice: ChoiceWhereInput
  isSuper: BooleanNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input BooleanNullableFilter {
  equals: Boolean
  not: BooleanNullableFilter
}

input BetWhereUniqueInput {
  id: ID
}

input BetOrderByInput {
  id: OrderDirection
  isSuper: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input BetUpdateInput {
  user: UserRelateToOneForUpdateInput
  choice: ChoiceRelateToOneForUpdateInput
  isSuper: Boolean
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input ChoiceRelateToOneForUpdateInput {
  create: ChoiceCreateInput
  connect: ChoiceWhereUniqueInput
  disconnect: Boolean
}

input BetUpdateArgs {
  where: BetWhereUniqueInput!
  data: BetUpdateInput!
}

input BetCreateInput {
  user: UserRelateToOneForCreateInput
  choice: ChoiceRelateToOneForCreateInput
  isSuper: Boolean
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input ChoiceRelateToOneForCreateInput {
  create: ChoiceCreateInput
  connect: ChoiceWhereUniqueInput
}

type Choice {
  id: ID!
  selection: ChoiceSelectionType
  isWin: Boolean
  line: Line
  bets(
    where: BetWhereInput! = {}
    orderBy: [BetOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Bet!]
  betsCount(where: BetWhereInput! = {}): Int
  status: ChoiceStatus
  labelName: String
}

enum ChoiceSelectionType {
  OVER
  UNDER
  AWAY
  HOME
}

enum ChoiceStatus {
  NOT_STARTED
  WINNING
  LOSING
  WON
  LOST
}

input ChoiceWhereInput {
  AND: [ChoiceWhereInput!]
  OR: [ChoiceWhereInput!]
  NOT: [ChoiceWhereInput!]
  id: IDFilter
  selection: ChoiceSelectionTypeNullableFilter
  isWin: BooleanNullableFilter
  line: LineWhereInput
  bets: BetManyRelationFilter
}

input ChoiceSelectionTypeNullableFilter {
  equals: ChoiceSelectionType
  in: [ChoiceSelectionType!]
  notIn: [ChoiceSelectionType!]
  not: ChoiceSelectionTypeNullableFilter
}

input BetManyRelationFilter {
  every: BetWhereInput
  some: BetWhereInput
  none: BetWhereInput
}

input ChoiceWhereUniqueInput {
  id: ID
}

input ChoiceOrderByInput {
  id: OrderDirection
  selection: OrderDirection
  isWin: OrderDirection
}

input ChoiceUpdateInput {
  selection: ChoiceSelectionType
  isWin: Boolean
  line: LineRelateToOneForUpdateInput
  bets: BetRelateToManyForUpdateInput
}

input LineRelateToOneForUpdateInput {
  create: LineCreateInput
  connect: LineWhereUniqueInput
  disconnect: Boolean
}

input BetRelateToManyForUpdateInput {
  disconnect: [BetWhereUniqueInput!]
  set: [BetWhereUniqueInput!]
  create: [BetCreateInput!]
  connect: [BetWhereUniqueInput!]
}

input ChoiceUpdateArgs {
  where: ChoiceWhereUniqueInput!
  data: ChoiceUpdateInput!
}

input ChoiceCreateInput {
  selection: ChoiceSelectionType
  isWin: Boolean
  line: LineRelateToOneForCreateInput
  bets: BetRelateToManyForCreateInput
}

input LineRelateToOneForCreateInput {
  create: LineCreateInput
  connect: LineWhereUniqueInput
}

input BetRelateToManyForCreateInput {
  create: [BetCreateInput!]
  connect: [BetWhereUniqueInput!]
}

type CloudImage {
  id: ID!
  image: CloudinaryImage_File
  altText: String
}

type CloudinaryImage_File {
  id: ID
  filename: String
  originalFilename: String
  mimetype: String
  encoding: String
  publicUrl: String
  publicUrlTransformed(transformation: CloudinaryImageFormat): String
}

"""
Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).
All options are strings as they ultimately end up in a URL.
"""
input CloudinaryImageFormat {
  """
   Rewrites the filename to be this pretty string. Do not include `/` or `.`
  """
  prettyName: String
  width: String
  height: String
  crop: String
  aspect_ratio: String
  gravity: String
  zoom: String
  x: String
  y: String
  format: String
  fetch_format: String
  quality: String
  radius: String
  angle: String
  effect: String
  opacity: String
  border: String
  background: String
  overlay: String
  underlay: String
  default_image: String
  delay: String
  color: String
  color_space: String
  dpr: String
  page: String
  density: String
  flags: String
  transformation: String
}

input CloudImageWhereInput {
  AND: [CloudImageWhereInput!]
  OR: [CloudImageWhereInput!]
  NOT: [CloudImageWhereInput!]
  id: IDFilter
  altText: StringNullableFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input CloudImageWhereUniqueInput {
  id: ID
}

input CloudImageOrderByInput {
  id: OrderDirection
  altText: OrderDirection
}

input CloudImageUpdateInput {
  image: Upload
  altText: String
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

input CloudImageUpdateArgs {
  where: CloudImageWhereUniqueInput!
  data: CloudImageUpdateInput!
}

input CloudImageCreateInput {
  image: Upload
  altText: String
}

type Contest {
  id: ID!
  name: String
  description: String
  status: ContestStatusType
  entryFee: Int
  image: CloudImage
  lines(
    where: LineWhereInput! = {}
    orderBy: [LineOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Line!]
  linesCount(where: LineWhereInput! = {}): Int
  registrations(
    where: RegistrationWhereInput! = {}
    orderBy: [RegistrationOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Registration!]
  registrationsCount(where: RegistrationWhereInput! = {}): Int
  ruleSet: RuleSet
}

enum ContestStatusType {
  OPEN
  IN_PROGRESS
  COMPLETE
}

input ContestWhereInput {
  AND: [ContestWhereInput!]
  OR: [ContestWhereInput!]
  NOT: [ContestWhereInput!]
  id: IDFilter
  name: StringNullableFilter
  description: StringNullableFilter
  status: ContestStatusTypeNullableFilter
  entryFee: IntNullableFilter
  image: CloudImageWhereInput
  lines: LineManyRelationFilter
  registrations: RegistrationManyRelationFilter
  ruleSet: RuleSetWhereInput
}

input ContestStatusTypeNullableFilter {
  equals: ContestStatusType
  in: [ContestStatusType!]
  notIn: [ContestStatusType!]
  not: ContestStatusTypeNullableFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input LineManyRelationFilter {
  every: LineWhereInput
  some: LineWhereInput
  none: LineWhereInput
}

input RegistrationManyRelationFilter {
  every: RegistrationWhereInput
  some: RegistrationWhereInput
  none: RegistrationWhereInput
}

input ContestWhereUniqueInput {
  id: ID
}

input ContestOrderByInput {
  id: OrderDirection
  name: OrderDirection
  description: OrderDirection
  status: OrderDirection
  entryFee: OrderDirection
}

input ContestUpdateInput {
  name: String
  description: String
  status: ContestStatusType
  entryFee: Int
  image: CloudImageRelateToOneForUpdateInput
  lines: LineRelateToManyForUpdateInput
  registrations: RegistrationRelateToManyForUpdateInput
  ruleSet: RuleSetRelateToOneForUpdateInput
}

input CloudImageRelateToOneForUpdateInput {
  create: CloudImageCreateInput
  connect: CloudImageWhereUniqueInput
  disconnect: Boolean
}

input LineRelateToManyForUpdateInput {
  disconnect: [LineWhereUniqueInput!]
  set: [LineWhereUniqueInput!]
  create: [LineCreateInput!]
  connect: [LineWhereUniqueInput!]
}

input RegistrationRelateToManyForUpdateInput {
  disconnect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  create: [RegistrationCreateInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RuleSetRelateToOneForUpdateInput {
  create: RuleSetCreateInput
  connect: RuleSetWhereUniqueInput
  disconnect: Boolean
}

input ContestUpdateArgs {
  where: ContestWhereUniqueInput!
  data: ContestUpdateInput!
}

input ContestCreateInput {
  name: String
  description: String
  status: ContestStatusType
  entryFee: Int
  image: CloudImageRelateToOneForCreateInput
  lines: LineRelateToManyForCreateInput
  registrations: RegistrationRelateToManyForCreateInput
  ruleSet: RuleSetRelateToOneForCreateInput
}

input CloudImageRelateToOneForCreateInput {
  create: CloudImageCreateInput
  connect: CloudImageWhereUniqueInput
}

input LineRelateToManyForCreateInput {
  create: [LineCreateInput!]
  connect: [LineWhereUniqueInput!]
}

input RegistrationRelateToManyForCreateInput {
  create: [RegistrationCreateInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RuleSetRelateToOneForCreateInput {
  create: RuleSetCreateInput
  connect: RuleSetWhereUniqueInput
}

type Line {
  id: ID!
  title: String
  closingTime: String
  benchmark: Float
  image: CloudImage
  contest: Contest
  choices(
    where: ChoiceWhereInput! = {}
    orderBy: [ChoiceOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Choice!]
  choicesCount(where: ChoiceWhereInput! = {}): Int
  standings(
    where: StandingWhereInput! = {}
    orderBy: [StandingOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Standing!]
  standingsCount(where: StandingWhereInput! = {}): Int
}

input LineWhereInput {
  AND: [LineWhereInput!]
  OR: [LineWhereInput!]
  NOT: [LineWhereInput!]
  id: IDFilter
  title: StringNullableFilter
  closingTime: DateTimeNullableFilter
  benchmark: FloatNullableFilter
  image: CloudImageWhereInput
  contest: ContestWhereInput
  choices: ChoiceManyRelationFilter
  standings: StandingManyRelationFilter
}

input DateTimeNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  not: DateTimeNullableFilter
}

input FloatNullableFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: FloatNullableFilter
}

input ChoiceManyRelationFilter {
  every: ChoiceWhereInput
  some: ChoiceWhereInput
  none: ChoiceWhereInput
}

input StandingManyRelationFilter {
  every: StandingWhereInput
  some: StandingWhereInput
  none: StandingWhereInput
}

input LineWhereUniqueInput {
  id: ID
}

input LineOrderByInput {
  id: OrderDirection
  title: OrderDirection
  closingTime: OrderDirection
  benchmark: OrderDirection
}

input LineUpdateInput {
  title: String
  closingTime: String
  benchmark: Float
  image: CloudImageRelateToOneForUpdateInput
  contest: ContestRelateToOneForUpdateInput
  choices: ChoiceRelateToManyForUpdateInput
  standings: StandingRelateToManyForUpdateInput
}

input ContestRelateToOneForUpdateInput {
  create: ContestCreateInput
  connect: ContestWhereUniqueInput
  disconnect: Boolean
}

input ChoiceRelateToManyForUpdateInput {
  disconnect: [ChoiceWhereUniqueInput!]
  set: [ChoiceWhereUniqueInput!]
  create: [ChoiceCreateInput!]
  connect: [ChoiceWhereUniqueInput!]
}

input StandingRelateToManyForUpdateInput {
  disconnect: [StandingWhereUniqueInput!]
  set: [StandingWhereUniqueInput!]
  create: [StandingCreateInput!]
  connect: [StandingWhereUniqueInput!]
}

input LineUpdateArgs {
  where: LineWhereUniqueInput!
  data: LineUpdateInput!
}

input LineCreateInput {
  title: String
  closingTime: String
  benchmark: Float
  image: CloudImageRelateToOneForCreateInput
  contest: ContestRelateToOneForCreateInput
  choices: ChoiceRelateToManyForCreateInput
  standings: StandingRelateToManyForCreateInput
}

input ContestRelateToOneForCreateInput {
  create: ContestCreateInput
  connect: ContestWhereUniqueInput
}

input ChoiceRelateToManyForCreateInput {
  create: [ChoiceCreateInput!]
  connect: [ChoiceWhereUniqueInput!]
}

input StandingRelateToManyForCreateInput {
  create: [StandingCreateInput!]
  connect: [StandingWhereUniqueInput!]
}

type Registration {
  id: ID!
  hasPaid: Boolean
  contest: Contest
  user: User
  counts: PointCounts
}

type PointCounts {
  locked: Int
  likely: Int
  possible: Int
}

input RegistrationWhereInput {
  AND: [RegistrationWhereInput!]
  OR: [RegistrationWhereInput!]
  NOT: [RegistrationWhereInput!]
  id: IDFilter
  hasPaid: BooleanNullableFilter
  contest: ContestWhereInput
  user: UserWhereInput
}

input RegistrationWhereUniqueInput {
  id: ID
}

input RegistrationOrderByInput {
  id: OrderDirection
  hasPaid: OrderDirection
}

input RegistrationUpdateInput {
  hasPaid: Boolean
  contest: ContestRelateToOneForUpdateInput
  user: UserRelateToOneForUpdateInput
}

input RegistrationUpdateArgs {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateInput!
}

input RegistrationCreateInput {
  hasPaid: Boolean
  contest: ContestRelateToOneForCreateInput
  user: UserRelateToOneForCreateInput
}

type RuleSet {
  id: ID!
  maxBets: Int
  maxSuperBets: Int
  superBetPointCount: Int
  contest: Contest
}

input RuleSetWhereInput {
  AND: [RuleSetWhereInput!]
  OR: [RuleSetWhereInput!]
  NOT: [RuleSetWhereInput!]
  id: IDFilter
  maxBets: IntNullableFilter
  maxSuperBets: IntNullableFilter
  superBetPointCount: IntNullableFilter
  contest: ContestWhereInput
}

input RuleSetWhereUniqueInput {
  id: ID
}

input RuleSetOrderByInput {
  id: OrderDirection
  maxBets: OrderDirection
  maxSuperBets: OrderDirection
  superBetPointCount: OrderDirection
}

input RuleSetUpdateInput {
  maxBets: Int
  maxSuperBets: Int
  superBetPointCount: Int
  contest: ContestRelateToOneForUpdateInput
}

input RuleSetUpdateArgs {
  where: RuleSetWhereUniqueInput!
  data: RuleSetUpdateInput!
}

input RuleSetCreateInput {
  maxBets: Int
  maxSuperBets: Int
  superBetPointCount: Int
  contest: ContestRelateToOneForCreateInput
}

type Standing {
  id: ID!
  gamesPlayed: Int
  wins: Int
  totalGames: Int
  line: Line
}

input StandingWhereInput {
  AND: [StandingWhereInput!]
  OR: [StandingWhereInput!]
  NOT: [StandingWhereInput!]
  id: IDFilter
  gamesPlayed: IntNullableFilter
  wins: IntNullableFilter
  totalGames: IntNullableFilter
  line: LineWhereInput
}

input StandingWhereUniqueInput {
  id: ID
}

input StandingOrderByInput {
  id: OrderDirection
  gamesPlayed: OrderDirection
  wins: OrderDirection
  totalGames: OrderDirection
}

input StandingUpdateInput {
  gamesPlayed: Int
  wins: Int
  totalGames: Int
  line: LineRelateToOneForUpdateInput
}

input StandingUpdateArgs {
  where: StandingWhereUniqueInput!
  data: StandingUpdateInput!
}

input StandingCreateInput {
  gamesPlayed: Int
  wins: Int
  totalGames: Int
  line: LineRelateToOneForCreateInput
}

type User {
  id: ID!
  email: String
  name: String
  userName: String
  password: PasswordState
  isAdmin: Boolean
  bets(
    where: BetWhereInput! = {}
    orderBy: [BetOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Bet!]
  betsCount(where: BetWhereInput! = {}): Int
  avatarImage: CloudImage
  registrations(
    where: RegistrationWhereInput! = {}
    orderBy: [RegistrationOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Registration!]
  registrationsCount(where: RegistrationWhereInput! = {}): Int
  passwordResetToken: PasswordState
  passwordResetIssuedAt: String
  passwordResetRedeemedAt: String
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  email: StringNullableFilter
  name: StringNullableFilter
  userName: StringNullableFilter
  password: PasswordFilter
  isAdmin: BooleanNullableFilter
  bets: BetManyRelationFilter
  avatarImage: CloudImageWhereInput
  registrations: RegistrationManyRelationFilter
  passwordResetToken: PasswordFilter
  passwordResetIssuedAt: DateTimeNullableFilter
  passwordResetRedeemedAt: DateTimeNullableFilter
}

input PasswordFilter {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
  userName: String
}

input UserOrderByInput {
  id: OrderDirection
  email: OrderDirection
  name: OrderDirection
  userName: OrderDirection
  isAdmin: OrderDirection
  passwordResetIssuedAt: OrderDirection
  passwordResetRedeemedAt: OrderDirection
}

input UserUpdateInput {
  email: String
  name: String
  userName: String
  password: String
  isAdmin: Boolean
  bets: BetRelateToManyForUpdateInput
  avatarImage: CloudImageRelateToOneForUpdateInput
  registrations: RegistrationRelateToManyForUpdateInput
  passwordResetToken: String
  passwordResetIssuedAt: String
  passwordResetRedeemedAt: String
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  email: String
  name: String
  userName: String
  password: String
  isAdmin: Boolean
  bets: BetRelateToManyForCreateInput
  avatarImage: CloudImageRelateToOneForCreateInput
  registrations: RegistrationRelateToManyForCreateInput
  passwordResetToken: String
  passwordResetIssuedAt: String
  passwordResetRedeemedAt: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type Query {
  validateUserPasswordResetToken(
    email: String!
    token: String!
  ): ValidateUserPasswordResetTokenResult
  authenticatedItem: AuthenticatedItem
  bets(
    where: BetWhereInput! = {}
    orderBy: [BetOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Bet!]
  bet(where: BetWhereUniqueInput!): Bet
  betsCount(where: BetWhereInput! = {}): Int
  choices(
    where: ChoiceWhereInput! = {}
    orderBy: [ChoiceOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Choice!]
  choice(where: ChoiceWhereUniqueInput!): Choice
  choicesCount(where: ChoiceWhereInput! = {}): Int
  cloudImages(
    where: CloudImageWhereInput! = {}
    orderBy: [CloudImageOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [CloudImage!]
  cloudImage(where: CloudImageWhereUniqueInput!): CloudImage
  cloudImagesCount(where: CloudImageWhereInput! = {}): Int
  contests(
    where: ContestWhereInput! = {}
    orderBy: [ContestOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Contest!]
  contest(where: ContestWhereUniqueInput!): Contest
  contestsCount(where: ContestWhereInput! = {}): Int
  lines(
    where: LineWhereInput! = {}
    orderBy: [LineOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Line!]
  line(where: LineWhereUniqueInput!): Line
  linesCount(where: LineWhereInput! = {}): Int
  registrations(
    where: RegistrationWhereInput! = {}
    orderBy: [RegistrationOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Registration!]
  registration(where: RegistrationWhereUniqueInput!): Registration
  registrationsCount(where: RegistrationWhereInput! = {}): Int
  ruleSets(
    where: RuleSetWhereInput! = {}
    orderBy: [RuleSetOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [RuleSet!]
  ruleSet(where: RuleSetWhereUniqueInput!): RuleSet
  ruleSetsCount(where: RuleSetWhereInput! = {}): Int
  standings(
    where: StandingWhereInput! = {}
    orderBy: [StandingOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Standing!]
  standing(where: StandingWhereUniqueInput!): Standing
  standingsCount(where: StandingWhereInput! = {}): Int
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  keystone: KeystoneMeta!
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  isOrderable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID!): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode!
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
